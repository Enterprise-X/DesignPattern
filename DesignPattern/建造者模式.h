#pragma once
#include "设计模式基类.h"

class 建造者模式 :public 设计模式基类
{
public:
	void 运行() override;
};

/*
* 
#有点像命令或策略模式

总结:
从客户端代码可以看到，客户端只需指定具体建造者，并作为参数传递给指挥者，通过指挥者即可得到结果。客户端无需关心House的建造方法和具体流程。如果要更换建造风格，只需更换具体建造者即可，不同建造者之间并无任何关联，方便替换。从代码优化角度来看，其实可以不需要指挥者Director的角色，而直接把construct方法放入具体建造者当中。

优点:
建造者模式中，客户端不需要知道产品内部组成细节，将产品本身和产品的创建过程分离，使同样的创建过程可以创建不同的产品对象；
不同建造者相互独立，并无任何挂链，方便替换。

缺点:
建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大

适用环境:
需要生成的产品对象有复杂的内部结构（通常包含多个成员变量）；
产品对象内部属性有一定的生成顺序；
同一个创建流程适用于多种不同的产品。

*/
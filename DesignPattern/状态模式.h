#pragma once
#include "设计模式基类.h"

class 状态模式 :public 设计模式基类
{

public:
	void 运行() override;

};


/*

优点:
状态模式封装了状态转换的规则，只给外界暴露了统一的接口，客户端可以无差别地调用该接口（如上述实例的客户端代码）
状态模式将所有与具体状态有关的行为放到一个类（具体状态类）中，只需要注入（依赖）不同的状态类对象到上下文类中，即可使上下文中拥有不同的行为

缺点:
状态模式增加了系统中类的个数（不同的具体状态类）
结构相对复杂（如前述实例的UML图），代码逻辑也较复杂
如果要增加新的状态，需要修改负责状态转换的代码，不符合开闭原则（如上述实例，如果增加了一个中间级别，是不是得修改很多状态转换的逻辑？）

适用环境:
对象的行为根据它的状态的改变而不同
代码中含有大量与对象状态有关的判断逻辑（if……else……或switch……case……）

*/
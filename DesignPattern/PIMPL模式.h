#pragma once
#include "设计模式基类.h"

class PIMPL模式 :public 设计模式基类
{

public:
	void 运行() override;

};

/*
该模式在QT中被广泛运用

优点:
1、信息隐藏
私有成员完全可以隐藏在共有接口之外，尤其对于闭源API的设计尤其的适合。
同时，很多代码会应用平台依赖相关的宏控制，这些琐碎的东西也完全可以隐藏在实现类当中，给用户一个简洁明了的使用接口。

2、加速编译
这通常是用pImpl手法的最重要的收益，称之为编译防火墙(compilation firewall)，主要是阻断了类的接口和类的实现两者的编译依赖性。
这样，类用户不需要额外include不必要的头文件，同时实现类的成员可以随意变更，而公有类的使用者不需要重新编译。

3、更好的二进制兼容性
通常对一个类的修改，会影响到类的大小、对象的表示和布局等信息，那么任何该类的用户都需要重新编译才行。而且即使更新的是外部不可访问的private部分，
虽然从访问性来说此时只有类成员和友元能否访问类的私有部分，但是私有部分的修改也会影响到类使用者的行为，这也迫使类的使用者需要重新编译。
而对于使用pImpl手法，如果实现变更被限制在实现类中，那公有类只持有一个实现类的指针，所以实现做出重大变更的情况下，pImpl也能够保证良好的二进制兼容性，这是pImpl的精髓所在。

4、惰性分配
实现类可以做到按需分配或者实际使用时候再分配，从而节省资源提高响应。


缺点:
a. PIMPL模式需要在调用和实现之间插入了一个指针，公有类在访问私有成员的时候都需要增加pImpl->前缀的方式，使用、阅读和调试都可能有所不便；

b. pImpl对拷贝操作比较敏感，要么禁止拷贝操作，要么就需要自定义拷贝操作；

c. 编译器将不再能够捕获const方法中对成员变量的修改，因为私有成员变量已经从公有类脱离到了实现类当中了，公有类的const只能保护指针值本身是否改变，
而不再能进一步保护其所指向的数据。如果要达到类似的保护效果，可以使用std::experimental::propagate_const技术。


*/
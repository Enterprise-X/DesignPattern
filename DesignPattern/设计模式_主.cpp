#include <iostream>
#include "设计模式管理器.h"

// DesignPattern.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//


/*
设计模式分类:

创建型:
#单例1_____简单工厂2_____工厂方法3_____抽象工厂4_____原型5_____建造者6#

结构型:
#适配器7_____桥接器8_____组合9_____装饰10_____外观11_____享元12_____代理13#

行为型:
#职责链14_____命令15_____解释器16_____迭代器17_____中介者18_____备忘录19_____观察者20_____状态21_____策略22_____模板方法23_____访问者24#

特殊型:
#PIMPL100
*/

int main()
{
    设计模式管理器 管理器;
	while (true)
	{
		printf("请输入设计模式(1-24 or 100),输入-1退出 -2帮助:\n");
		int modeType;
		std::cin >> modeType;
		system("cls");
		if ((modeType>=(枚举_设计模式::单例) && modeType <= (枚举_设计模式::访问者))||(modeType== 枚举_设计模式::PIMPL))
		{
			管理器.运行((枚举_设计模式)modeType);
		}
		if (modeType == -1)
		{
			break;
		}
		if (modeType == -2)
		{
			printf("创建型:\n");
			printf("单例1_____简单工厂2_____工厂方法3_____抽象工厂4_____原型5_____建造者6\n");
			printf("结构型:\n");
			printf("适配器7_____桥接器8_____组合9_____装饰10_____外观11_____享元12_____代理13\n");
			printf("行为型:\n");
			printf("职责链14_____命令15_____解释器16_____迭代器17_____中介者18_____备忘录19_____观察者20_____状态21_____策略22_____模板方法23_____访问者24\n");
			printf("特殊型:\n");
			printf("PIMPL100\n");
		}
	}

    //system("pause");
    return 0;
}

/*

#在实际工程开发中常用到的_AND_个人觉得好用的设计模式:
*:个人觉得好用的

1.创建型
	1.1 单例:		私构静实(私有构造,静态实例)										static private 构造()
	1.2 简单工厂:	据名生类(根据名称/类型生成对应实例类)							(cls* getCls(type)→switch(type){new typeCls})
	1.3 工厂方法:	一品一厂(一个工厂生成一个类型的实例类)							A-Product→A-Factory ...N-P→N-F....
	1.4 抽象工厂:	一厂多品(一个工厂生成有共性的多种类型的实例类)					A-F:A-P1/A-P2/....A-Pn B-F:B-P1/B-P2/....B-Pn
	*1.8 原型:		克隆本我(使用clone接口生成new的"this",根据需求灵活赋值)			*cls Clone()

2.结构型
	2.1 适配器:		一接调多(一个接口调用多个不同实例类的接口)						Aper.func()→{A1.func()....An.func()}
	2.2 组合:		树与节点(常用于树型数据结构的定义,节点传递嵌套)					Node.add(Node)
	2.3 装饰:		链式操作(链式调用设置的接口,先套娃后调用)						A.set(B)→B.set(C)→C.set(D)  ==> A.func()→B.func→C.func→D.func
	2.4 代理:		一接调异(作为中间类调用其他实例类的接口)						A.Proxy()→B.exec()
	*2.5 桥接器:	灵活切换(根据设置,灵活调用不同实例类的接口)						A.set(X)==>A.exec()→X.exec   A.set(Y)==>A.exec()→Y.exec
	*2.6 外观:		一接调藏(调用类中隐藏的其他实例类)								A.exec()→X/Y/Z→exec()
	*2.7 享元:		据名得类(根据名称/类型获取泛型容器中的实例类)					(Val* getValByKey(Key){ 字典/列表(Key) })

3.行为型
	3.1 命令:		设令运行(设置命令,调用接口运行)									A.add(CMD1)..A.add(CMDn) ==> A.exec()
	3.2 观察者:		注册广播(注册消息体,消息广播给所有消息体)						Mgr.add(Mer1)...Mgr.add(Mern) ==> Mgr.send(Msg)→for(Meri.recv(msg))
	3.3 状态:		据态执异(根据当前状态执行不同的操作)							Mgr.set(State1) ==>Mgr.exec()->switch(curState){ state.exec()}
	3.4 策略:		置法执异(根据设置的算法类,执行不同的算法)						Mgr.set(Strategy)==>Mgr.exec()->Strategy.exec()
	*3.5 职责链:	据链执传(根据判断是否在当前链节点执行相应动作或者向后传递动作)	A.setPar(B) B.setPar(C)...N.setPar(N+1) ==> A.exec→(val?exec(val):par.exec(val))




补充:
#1_三种类似的结构型设计模式之间的区别
	1_.适配器模式: 把真实的实现模块（一个或者多个对象，或者就是函数库）中，一个一个方法（或者函数），依次匹配到客户需要的格式，与客户代码一起工作；
	2_.外观模式:把真实实现的模块（即，现有系统，往往比较复杂、功能强大，但新形势下不需要全部的功能）中有用的部分进行一定的分析、组合、添加，形成一套简洁实用的接口，供多个客户同时使用；
	3_.代理模式:  把客户与真实的对象（比如一个服务器对象）之间，通过代理进行隔离。客户只要访问代理，由代理把客户请求转发给真实的对象。代理模式 是代理一个对象。供多个客户使用。


*/







/*
#设计模式原则

01.单一职责原则：
【
定义1：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。
定义2：就一个类而言，应该仅有一个引起它变化的原因。
】

首先需要知道两个原则：高内聚和低耦合：
高内聚：内聚是对软件系统中元素职责相关性和集中度的度量。如果元素具有高度相关的职责，除了这些职责内的任务，没有其它过多的工作，那么该元素就具有高内聚性；反之则成为低内聚性。
低耦合：耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据
单一职责原则用于控制类的力度大小。软件设计过程中，如果一个类承担的职责越多，那么它被复用的可能性越小。
（为什么？想想，如果一个类有许多接口，另一个类想复用其中一两个接口，还不如重新实现！）。
另一方面，如果一个类承担的职责越多，各个职责耦合在一起，修改其中一个职责可能“牵一发而动全身”。
因此，应该将这些职责进行分离，不同的职责封装在不同的类中。


02.开闭原则：
【软件实体应对扩展开放，对修改关闭】

开闭原则指软件实体（一个软件模块、一个由不同类组成的局部结构或一个独立的类） 应该在不修改原有代码的基础上进行扩展。
软件设计过程中，需求可能会随时变化，需要根据需求扩展已有的设计。
如果原有的设计符合开闭原则，那么扩展起来就比较安全（不会影响原有功能，稳定）和方便（易于扩展）。
开闭原则的关键在于抽象化。可以为系统定义一个相对较为稳定的抽象层，将不同的实现行为放到具体的实现层中完成。

03.里氏代换原则：
【所有引用基类的地方必须能透明地使用其子类的对象】

在软件中，如果用子类对象来替换基类对象，程序将不会产生任何异常和问题，反过来不成立。
为什么？很好理解，子类继承自基类，基类有的成员方法和成员属性，子类全都有；而子类可以增加新的方法和属性，所以反过来不成立。
里氏代换原则的指导意义在于：尽可能地使用基类类型来对对象进行定义，而在运行时再确定子类类型，然后用子类对象替换父类对象。
设计时应将父类设计为抽象类或者接口，子类继承父类并实现在父类中声明的方法；运行时子类实例（对象）替换父类实例（对象），可以很方便地扩展系统功能。

04.依赖倒转原则：
【高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象】

什么是高层，什么是低层呢？它们指的是继承（派生）中的基类子类关系，基类或者越抽象的类，层次越高。
简单说，依赖倒转原则要求针对接口编程，不要针对实现编程。
依赖倒转原则要求再程序代码中传递参数时，或在关联关系中，尽量引用层次高的出现层类，即使用接口或抽象类来声明变量类型、参数类型声明、方法返回类型声明，
以及数据类型转换等，而不要使用具体类来做这些事情。（其实这一点也符合里氏代换原则的指导意义，即对一个方法而言，返回基类的地方一定可以返回子类）。
同样，依赖倒转原则设计的关键也在与抽象化设计。

05.接口隔离原则：
【客户端不应该依赖那些它不需要的接口】

当一个接口太大时，应该将它根据需要分割成多个更细小的接口，每个接口仅承担一个相对独立的角色或功能，使用该接口的客户端仅需知道与之相关的方法即可。 
但是，接口不能过小，否则系统中接口太多，不利于维护。一般而言，在接口中仅包含为某一类用户定制的方法即可。

06.迪米特法则：
【每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位】

迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。
如果一个系统负荷迪米特法则，那么当修改其中某一个模块时就会尽量少地影响其他模块。
应用迪米特法则可以降低系统的耦合度。在类的设计上应该注意以下几点：在类的划分上应尽量创建松耦合的类，类之间的耦合度越低，越有利于复用；
类的结构设计上，每一个类都应该降低其成员变量和成员函数的访问权限。

07.
合成复用原则：
【优先使用对象组合，而不是通过继承来达到复用的目的】

根据UML类图关系，合成复用原则指导在软件设计时，优先使用关联、聚合和组合关系，尽量少用泛化（继承）。
对象组合可以使系统更加灵活（黑箱复用），降低类与类之间的耦合度，一个类的变化尽可能不影响其他类（父类和子类耦合度高不高？）。
如果要使用继承，则需考虑里氏代换原则和依赖倒转原则。继承关系会破坏系统的封装性，
会将基类的实现细节暴露给子类（白箱复用），如果基类发生改变，那么子类的实现也不得不改变。

*/